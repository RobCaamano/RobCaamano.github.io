<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Study Notes – Docs-Style</title>
  <style>
    :root{
      --sidebar-bg: #1b5e20; /* deep green */
      --sidebar-accent: #2e7d32;
      --sidebar-text: #e8f5e9;
      --sidebar-text-dim: #c8e6c9;
      --bg: #ffffff;
      --text: #111;
      --muted: #6b7280;
      --border: #e5e7eb;
      --focus: #2563eb;
      --danger: #b91c1c;
      --toolbar-bg: #f8fafc;
      --disabled: #9ca3af33;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,"Helvetica Neue",Arial,"Apple Color Emoji","Segoe UI Emoji";
      color:var(--text);
      background:var(--bg);
    }
    .app{
      display:grid;
      grid-template-columns: 280px 1fr;
      grid-template-rows: 56px 1fr;
      grid-template-areas:
        "sidebar header"
        "sidebar main";
      height:100vh;
      overflow:hidden;
    }
    header{
      grid-area: header;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
      padding: 0 16px;
      border-bottom:1px solid var(--border);
      background:#fff;
    }
    header .left{display:flex; align-items:center; gap:12px}
    header h1{
      font-size:16px;
      margin:0;
      font-weight:600;
    }
    header .actions{display:flex; gap:8px; align-items:center}
    header .actions .btn{
      border:1px solid var(--border);
      background:#fff;
      color:#111;
      padding:6px 10px;
      border-radius:6px;
      font-size:12px;
      cursor:pointer;
    }
    header .actions .btn[disabled]{opacity:.5; cursor:not-allowed}
    header .actions .btn:hover{background:#f3f4f6}
    aside{
      grid-area: sidebar;
      background:var(--sidebar-bg);
      color:var(--sidebar-text);
      display:flex;
      flex-direction:column;
      border-right:1px solid rgba(255,255,255,0.08);
      overflow:hidden;
    }
    .sidebar-top{
      padding:12px;
      border-bottom:1px solid rgba(255,255,255,0.1);
    }
    .search{
      position:relative;
    }
    .search input{
      width:100%;
      padding:10px 10px 10px 32px;
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.2);
      background:rgba(255,255,255,0.08);
      color:#fff;
      outline:none;
    }
    .search input::placeholder{color:var(--sidebar-text-dim)}
    .search svg{
      position:absolute; left:8px; top:50%; transform:translateY(-50%);
      width:16px;height:16px; opacity:.8;
    }
    .sidebar-actions{
      display:flex; gap:8px; margin-top:10px;
    }
    .btn{
      appearance:none;
      border:1px solid rgba(255,255,255,0.2);
      background:rgba(255,255,255,0.06);
      color:#fff;
      padding:8px 10px;
      border-radius:6px;
      font-size:12px;
      cursor:pointer;
    }
    .btn:hover{background:rgba(255,255,255,0.12)}
    .btn[disabled]{opacity:.5; cursor:not-allowed}
    .tree{
      padding:8px 0;
      overflow:auto;
      flex:1;
    }
    .tree .home, .tree .node{
      display:flex; align-items:center; gap:8px;
      padding:6px 12px; cursor:pointer; user-select:none;
      color:var(--sidebar-text);
    }
    .tree .home:hover, .tree .node:hover{background:rgba(255,255,255,0.08)}
    .tree .node.selected, .tree .home.selected{background:rgba(255,255,255,0.15)}
    .label{flex:1; white-space:nowrap; overflow:hidden; text-overflow:ellipsis}
    .dim{color:var(--sidebar-text-dim)}
    .twisty{width:14px;height:14px; display:inline-flex; align-items:center; justify-content:center}
    .children{margin-left:16px;}
    .node .actions{display:none; gap:6px}
    .node:hover .actions{display:flex}
    .tree button.icon{
      background:none; border:none; padding:2px; cursor:pointer; color:var(--sidebar-text-dim);
    }
    .tree button.icon:hover{color:#fff}
    main{
      grid-area: main;
      display:flex;
      flex-direction:column;
      overflow:hidden;
    }
    .toolbar{
      background:var(--toolbar-bg);
      border-bottom:1px solid var(--border);
      padding:8px;
      display:flex; align-items:center; gap:8px; flex-wrap:wrap;
    }
    .toolbar.disabled{pointer-events:none; opacity:.5}
    .toolbar .tool-btn, .toolbar select, .toolbar input[type="color"]{
      appearance:none;
      border:1px solid var(--border);
      background:#fff;
      padding:8px 10px;
      border-radius:6px;
      font-size:13px;
      cursor:pointer;
    }
    .tool-btn:hover{background:#f3f4f6}
    .tool-btn.active{background:#e5e7eb}
    .tool-sep{width:1px; height:28px; background:var(--border); margin:0 2px}
    .editor-wrap{
      position:relative;
      overflow:auto;
      flex:1;
      padding:16px;
    }
    .titlebar{
      display:flex; gap:12px; align-items:center; margin:0 0 8px 0;
    }
    .titlebar input{
      font-size:20px; font-weight:600; border:1px solid var(--border);
      border-radius:8px; padding:8px 10px; flex:1;
    }
    #editor{
      min-height:60vh;
      outline:none;
      border:1px solid var(--border);
      border-radius:8px;
      padding:16px;
      line-height:1.6;
      scroll-behavior:smooth;
    }
    #editor[contenteditable="false"]{background:#fafafa}
    #editor img{max-width:100%; height:auto; display:block; margin:8px 0}
    mjx-container[contenteditable="false"]{user-select:text}
    .placeholder{color:#9ca3af}
    .empty-hint{
      padding:24px; color:#374151;
    }
    .status{
      position:fixed; bottom:12px; right:12px; background:#111827; color:#e5e7eb;
      padding:8px 12px; border-radius:999px; font-size:12px; opacity:0; transition:.2s; z-index:2000;
    }
    .status.show{opacity:1}
    /* Modal */
    .modal-backdrop{
      position:fixed; inset:0; background:rgba(0,0,0,.35); display:none; align-items:center; justify-content:center; z-index:1500;
    }
    .modal{
      background:#fff; border-radius:12px; width:min(760px, calc(100% - 24px));
      border:1px solid var(--border);
      box-shadow: 0 20px 40px rgba(0,0,0,.15);
      overflow:hidden;
      max-height:80vh; display:flex; flex-direction:column;
    }
    .modal header{
      border-bottom:1px solid var(--border); padding:12px 16px; display:flex; align-items:center; justify-content:space-between;
    }
    .modal .body{padding:16px; overflow:auto}
    .modal footer{padding:12px 16px; border-top:1px solid var(--border); display:flex; gap:8px; justify-content:flex-end}
    .modal textarea, .modal input[type="text"], .modal input[type="url"], .modal select, .modal input[type="password"]{
      width:100%; padding:10px; border-radius:8px; border:1px solid var(--border); font-family:inherit; font-size:14px;
    }
    .btn-ghost{background:#fff; color:#111; border:1px solid var(--border)}
    .btn-primary{background:#111827; color:#fff; border:1px solid #111827}
    .danger{color:#fff; background:var(--danger); border-color:var(--danger)}
    /* Search results styling */
    .result{padding:10px 0; border-bottom:1px solid var(--border)}
    .result .where{font-size:12px; color:#6b7280}
    .result .snippet{font-size:14px; margin-top:6px}
    mark{background:#fff59d}
    /* Responsive */
    @media (max-width: 880px){
      .app{grid-template-columns: 220px 1fr;}
    }
    @media (max-width: 720px){
      .app{
        grid-template-columns: 1fr;
        grid-template-rows: 56px auto 1fr;
        grid-template-areas:
          "header"
          "sidebar"
          "main";
      }
      aside{max-height:320px}
    }
  </style>
  <!-- MathJax for LaTeX -->
  <script>
    window.MathJax = {
      tex: {
        inlineMath: [['\\(','\\)'], ['$', '$']],
        displayMath: [['\\[','\\]'], ['$$','$$']]
      },
      svg: { fontCache: 'global' }
    };
  </script>
  <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
<div class="app">
  <aside>
    <div class="sidebar-top">
      <div class="search">
        <svg viewBox="0 0 24 24" fill="currentColor"><path d="M15.5 14h-.79l-.28-.27a6.471 6.471 0 001.48-5.34C15.19 5.01 12.17 2 8.59 2S2 5.01 2 8.39c0 3.39 3.02 6.39 6.59 6.39 1.61 0 3.09-.59 4.22-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6.91 0C5.51 14 3 11.5 3 8.39 3 5.28 5.51 2.78 8.59 2.78c3.07 0 5.58 2.5 5.58 5.61 0 3.11-2.51 5.61-5.58 5.61z"/></svg>
        <input id="search" placeholder="Search sections, pages & content…" />
      </div>
      <div class="sidebar-actions">
        <button id="addSectionBtn" class="btn">+ Section</button>
        <button id="addPageBtn" class="btn">+ Page</button>
      </div>
    </div>
    <div class="tree" id="tree">
      <!-- Tree content injected by JS -->
    </div>
  </aside>

  <header>
    <div class="left">
      <h1 id="crumb">Home</h1>
    </div>
    <div class="actions">
      <button id="exportBtn" class="btn">Export</button>
      <button id="importBtn" class="btn">Import</button>
      <button id="githubBtn" class="btn">GitHub Sync</button>
      <button id="editToggleBtn" class="btn">Unlock Editing</button>
      <input type="file" id="importFile" accept="application/json" style="display:none"/>
    </div>
  </header>

  <main>
    <div class="toolbar" id="toolbar">
      <button class="tool-btn" data-cmd="bold"><b>B</b></button>
      <button class="tool-btn" data-cmd="italic"><em>I</em></button>
      <button class="tool-btn" data-cmd="underline"><u>U</u></button>
      <div class="tool-sep"></div>
      <select id="headingSelect" title="Heading">
        <option value="p">Paragraph</option>
        <option value="h1">H1</option>
        <option value="h2">H2</option>
        <option value="h3">H3</option>
      </select>
      <select id="fontSizeSelect" title="Font size">
        <option value="default">Font size</option>
        <option value="12px">12</option>
        <option value="14px">14</option>
        <option value="16px">16</option>
        <option value="18px">18</option>
        <option value="20px">20</option>
        <option value="24px">24</option>
        <option value="28px">28</option>
      </select>
      <select id="lineHeightSelect" title="Line spacing">
        <option value="default">Line spacing</option>
        <option value="1.3">1.3</option>
        <option value="1.6">1.6</option>
        <option value="1.8">1.8</option>
        <option value="2.0">2.0</option>
      </select>
      <input type="color" id="colorPicker" title="Text color"/>
      <div class="tool-sep"></div>
      <button class="tool-btn" data-cmd="insertUnorderedList">• List</button>
      <button class="tool-btn" data-cmd="insertOrderedList">1. List</button>
      <button class="tool-btn" id="linkBtn">Link</button>
      <div class="tool-sep"></div>
      <button class="tool-btn" id="imageBtn">Image</button>
      <button class="tool-btn" id="formulaBtn">Formula</button>
      <button class="tool-btn" id="clearFormatBtn" title="Clear formatting">Clear</button>
      <input type="file" id="imageInput" accept="image/*" style="display:none" />
    </div>

    <div class="editor-wrap">
      <div class="titlebar">
        <input id="titleInput" placeholder="Title"/>
        <span id="saveIndicator" class="dim">Saved</span>
      </div>
      <div id="editor" contenteditable="true" spellcheck="true"></div>
      <div class="empty-hint" id="emptyHint" style="display:none">
        <h3>This is a section</h3>
        <p>Sections hold pages. Use <strong>+ Page</strong> to add notes.</p>
      </div>
    </div>
  </main>
</div>

<div class="status" id="status">Saved</div>

<!-- Modal (generic) -->
<div class="modal-backdrop" id="modalBackdrop" role="dialog" aria-modal="true">
  <div class="modal" role="document">
    <header>
      <strong id="modalTitle">Insert</strong>
      <button id="modalClose" class="btn btn-ghost">✕</button>
    </header>
    <div class="body" id="modalBody"></div>
    <footer id="modalFooter">
      <button class="btn btn-ghost" id="modalCancel">Cancel</button>
      <button class="btn btn-primary" id="modalOk">OK</button>
    </footer>
  </div>
</div>

<script>
(() => {
  // ---------- Utility ----------
  const $ = (sel, root=document) => root.querySelector(sel);
  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));
  const debounce = (fn, d=500) => { let t; return (...a)=>{ clearTimeout(t); t=setTimeout(()=>fn(...a), d); }; };
  const uuid = () => (crypto?.randomUUID?.() || 'id-'+Math.random().toString(36).slice(2));
  const utf8ToB64 = (str)=> btoa(unescape(encodeURIComponent(str)));
  const sha256 = async (text) => {
    const enc = new TextEncoder().encode(text);
    const buf = await crypto.subtle.digest('SHA-256', enc);
    return Array.from(new Uint8Array(buf)).map(b=>b.toString(16).padStart(2,'0')).join('');
  };

  // ---------- IndexedDB ----------
  const DB_NAME = 'notesdb_v1';
  const STORE = 'nodes';
  let db;
  function idbOpen(){
    return new Promise((resolve, reject) => {
      const req = indexedDB.open(DB_NAME, 1);
      req.onupgradeneeded = e => {
        const db = req.result;
        if(!db.objectStoreNames.contains(STORE)){
          const store = db.createObjectStore(STORE, { keyPath: 'id' });
          store.createIndex('parentId', 'parentId', { unique: false });
          store.createIndex('type', 'type', { unique: false });
        }
      };
      req.onsuccess = ()=> resolve(req.result);
      req.onerror = ()=> reject(req.error);
    });
  }
  function tx(storeName=STORE, mode='readonly'){
    const t = db.transaction(storeName, mode);
    return [t, t.objectStore(storeName)];
  }
  async function idbGetAll(){
    const [t, s] = tx();
    return new Promise((res, rej)=>{
      const req = s.getAll();
      req.onsuccess = ()=> res(req.result);
      req.onerror = ()=> rej(req.error);
    });
  }
  async function idbPut(node){
    const [t, s] = tx(STORE, 'readwrite');
    return new Promise((res, rej)=>{
      const req = s.put(node);
      req.onsuccess = ()=> res(req.result);
      req.onerror = ()=> rej(req.error);
    });
  }
  async function idbGet(id){
    const [t, s] = tx();
    return new Promise((res, rej)=>{
      const req = s.get(id);
      req.onsuccess = ()=> res(req.result);
      req.onerror = ()=> rej(req.error);
    });
  }
  async function idbDelete(id){
    const [t, s] = tx(STORE, 'readwrite');
    return new Promise((res, rej)=>{
      const req = s.delete(id);
      req.onsuccess = ()=> res();
      req.onerror = ()=> rej(req.error);
    });
  }
  async function idbClear(){
    const [t, s] = tx(STORE, 'readwrite');
    return new Promise((res, rej)=>{
      const req = s.clear();
      req.onsuccess = ()=> res();
      req.onerror = ()=> rej(req.error);
    });
  }

  // ---------- Data Model ----------
  // Node: { id, type: 'home'|'section'|'page', title, contentHtml?, parentId?, order? }
  let state = {
    nodes: [],
    selectedId: 'home',
    expanded: JSON.parse(localStorage.getItem('expanded') || '[]'), // section ids
    filter: ''
  };

  async function ensureHome(){
    const hasHome = state.nodes.find(n=>n.id==='home');
    if(!hasHome){
      const home = {
        id:'home', type:'home', title:'Home',
        contentHtml: `<h1>Welcome</h1>
<p>This is your docs-style notes space. Use the green sidebar to add sections and pages. Everything is saved locally in your browser (IndexedDB). If configured, GitHub Sync keeps your <code>notes-export.json</code> in this repo up to date so every viewer sees the same content.</p>`
      };
      state.nodes.push(home);
      await idbPut(home);
    }
  }

  function persistExpanded(){
    localStorage.setItem('expanded', JSON.stringify(state.expanded));
  }

  function toggleExpanded(sectionId){
    const i = state.expanded.indexOf(sectionId);
    if(i>=0) state.expanded.splice(i,1);
    else state.expanded.push(sectionId);
    persistExpanded();
    renderTree();
  }

  // ---------- Rendering ----------
  function renderTree(){
    const wrap = $('#tree');
    wrap.innerHTML = '';

    const filter = state.filter.trim().toLowerCase();
    const match = (s) => s.toLowerCase().includes(filter);

    // Home
    const home = state.nodes.find(n=>n.id==='home');
    if(home && (filter==='' || match('home'))){
      const el = document.createElement('div');
      el.className = 'home' + (state.selectedId==='home'?' selected':'');
      el.innerHTML = `<span class="twisty">🏠</span><span class="label">Home</span>`;
      el.onclick = ()=> selectNode('home');
      wrap.appendChild(el);
    }

    // Sections and pages
    const sections = state.nodes.filter(n=>n.type==='section').sort((a,b)=>(a.order||0)-(b.order||0));
    const pagesByParent = new Map();
    for(const p of state.nodes.filter(n=>n.type==='page')){
      const list = pagesByParent.get(p.parentId) || [];
      list.push(p);
      pagesByParent.set(p.parentId, list);
    }
    for(const [k, v] of pagesByParent.entries()){
      v.sort((a,b)=>(a.order||0)-(b.order||0));
    }

    function sectionMatches(section){
      if(filter==='' ) return true;
      if(match(section.title)) return true;
      const pages = pagesByParent.get(section.id) || [];
      const pageTitleHit = pages.some(p=>match(p.title));
      if(pageTitleHit) return true;
      // simple content match for sections
      const sectionText = textFromHtml(section.contentHtml || '');
      if(sectionText.toLowerCase().includes(filter)) return true;
      // page content match
      for(const p of (pagesByParent.get(section.id) || [])){
        const t = textFromHtml(p.contentHtml || '');
        if(t.toLowerCase().includes(filter)) return true;
      }
      return false;
    }

    for(const sec of sections){
      if(!sectionMatches(sec)) continue;

      const secEl = document.createElement('div');
      secEl.className = 'node' + (state.selectedId===sec.id?' selected':'');
      const isOpen = state.expanded.includes(sec.id);
      secEl.innerHTML = `
        <span class="twisty">${isOpen?'▾':'▸'}</span>
        <span class="label">${escapeHtml(sec.title)}</span>
        <span class="actions">
          <button class="icon" title="Rename">✎</button>
          <button class="icon" title="Add page">＋</button>
          <button class="icon" title="Delete">🗑</button>
        </span>`;
      secEl.onclick = (e)=>{
        if(e.target.closest('button')) return; // action buttons
        toggleExpanded(sec.id);
      };
      secEl.dataset.id = sec.id;
      wrap.appendChild(secEl);

      const actions = secEl.querySelectorAll('button.icon');
      actions[0].onclick = async (e)=>{ e.stopPropagation(); await promptRename(sec.id); };
      actions[1].onclick = async (e)=>{ e.stopPropagation(); await addPage(sec.id); };
      actions[2].onclick = async (e)=>{ e.stopPropagation(); await deleteNode(sec.id); };

      // Click label selects section for editing overview
      secEl.querySelector('.label').onclick = (e)=>{ e.stopPropagation(); selectNode(sec.id); };

      if(isOpen){
        const childrenEl = document.createElement('div');
        childrenEl.className = 'children';
        const pages = (pagesByParent.get(sec.id) || []).filter(p=> filter==='' || match(p.title));
        for(const p of pages){
          const pageEl = document.createElement('div');
          pageEl.className = 'node' + (state.selectedId===p.id?' selected':'');
          pageEl.innerHTML = `<span class="twisty">📄</span><span class="label">${escapeHtml(p.title)}</span>
            <span class="actions">
              <button class="icon" title="Rename">✎</button>
              <button class="icon" title="Delete">🗑</button>
            </span>`;
          pageEl.onclick = ()=> selectNode(p.id);
          const acts = pageEl.querySelectorAll('button.icon');
          acts[0].onclick = async (e)=>{ e.stopPropagation(); await promptRename(p.id); };
          acts[1].onclick = async (e)=>{ e.stopPropagation(); await deleteNode(p.id); };
          childrenEl.appendChild(pageEl);
        }
        wrap.appendChild(childrenEl);
      }
    }

    if(sections.length===0){
      const empty = document.createElement('div');
      empty.className = 'node dim';
      empty.style.cursor='default';
      empty.innerHTML = '<span class="twisty">ⓘ</span><span class="label">No sections yet. Click "+ Section".</span>';
      wrap.appendChild(empty);
    }
  }

  function escapeHtml(s){ return s.replace(/[&<>"]/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;' }[c])); }

  async function selectNode(id){
    state.selectedId = id;
    const node = state.nodes.find(n=>n.id===id);
    $('#crumb').textContent = node?.title || 'Untitled';
    if(node){
      $('#emptyHint').style.display='none';
      $('#titleInput').style.display='block';
      $('#editor').style.display='block';
      $('#titleInput').value = node.title || '';
      $('#editor').innerHTML = node.contentHtml || '';
      MathJax?.typesetPromise?.([$('#editor')]).then(()=>{
        hardenMathJax();
        ensureCaretOutsideMath();
      });
    }
    renderTree();
    updateEditability();
  }

  // ---------- CRUD ----------
  async function addSection(){
    const title = await promptModal('New Section', 'Section title', '');
    if(title === null) return;
    const node = { id: uuid(), type:'section', title: title.trim() || 'Untitled Section', order: Date.now(), contentHtml:'<p>Section overview…</p>' };
    state.nodes.push(node);
    await idbPut(node);
    if(!state.expanded.includes(node.id)){ state.expanded.push(node.id); persistExpanded(); }
    renderTree();
    selectNode(node.id);
  }

  async function addPage(parentId){
    let title = await promptModal('New Page', 'Page title', '');
    if(title===null) return;
    title = title.trim() || 'Untitled Page';
    const node = { id: uuid(), type:'page', parentId, title, order: Date.now(), contentHtml: '<p></p>' };
    state.nodes.push(node);
    await idbPut(node);
    renderTree();
    selectNode(node.id);
  }

  async function promptRename(id){
    const node = state.nodes.find(n=>n.id===id);
    if(!node) return;
    const title = await promptModal('Rename', 'New title', node.title || '');
    if(title===null) return;
    node.title = title.trim() || node.title;
    await idbPut(node);
    if(id===state.selectedId){ $('#crumb').textContent = node.title; $('#titleInput').value = node.title; }
    renderTree();
  }

  async function deleteNode(id){
    const node = state.nodes.find(n=>n.id===id);
    if(!node) return;
    if(node.type==='home'){ toast('Cannot delete Home'); return; }
    let msg = 'Delete "'+node.title+'"?';
    if(node.type==='section'){
      const childCount = state.nodes.filter(n=>n.parentId===id && n.type==='page').length;
      if(childCount>0) msg += ` This will also delete ${childCount} page(s).`;
    }
    const ok = await confirmModal('Delete', msg);
    if(!ok) return;

    if(node.type==='section'){
      const children = state.nodes.filter(n=>n.parentId===id);
      for(const c of children){ await idbDelete(c.id); }
      state.nodes = state.nodes.filter(n=>n.parentId!==id);
    }
    await idbDelete(id);
    state.nodes = state.nodes.filter(n=>n.id!==id);
    if(state.selectedId===id) selectNode('home');
    renderTree();
  }

  // ---------- Editor + Toolbar ----------
  const editor = $('#editor');
  const titleInput = $('#titleInput');
  const saveIndicator = $('#saveIndicator');

  let lastRange = null;

  function selectionInsideEditor(){
    const sel = window.getSelection();
    if(!sel || sel.rangeCount===0) return false;
    const r = sel.getRangeAt(0);
    return editor.contains(r.startContainer) && editor.contains(r.endContainer);
  }

  function saveSelection(){
    const sel = window.getSelection();
    if(!sel || sel.rangeCount===0) return;
    const r = sel.getRangeAt(0);
    if(editor.contains(r.startContainer)){
      lastRange = r.cloneRange();
    }
  }
  function restoreSelection(){
    if(lastRange){
      const sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(lastRange);
    }else{
      editor.focus();
      const range = document.createRange();
      range.selectNodeContents(editor);
      range.collapse(false);
      const sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
      lastRange = range.cloneRange();
    }
  }
  function placeCaretAfter(node){
    const range = document.createRange();
    range.setStartAfter(node);
    range.setEndAfter(node);
    const sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
    saveSelection();
  }
  function nearestBlock(node){
    if(node && node.nodeType===3) node = node.parentElement;
    return node?.closest('p,div,li,h1,h2,h3,h4,h5,h6,pre,blockquote') || editor;
  }
  function ensureCaretOutsideMath(){
    const sel = window.getSelection();
    if(!sel || !sel.rangeCount) return;
    let anchor = sel.anchorNode;
    if(anchor && anchor.nodeType===3) anchor = anchor.parentElement;
    const mjx = anchor?.closest ? anchor.closest('mjx-container') : null;
    if(mjx){
      const parent = mjx.parentNode;
      const next = mjx.nextSibling;
      if(!(next && next.nodeType===3 && /^\s$/.test(next.nodeValue))){
        const spacer = document.createTextNode(' ');
        parent.insertBefore(spacer, mjx.nextSibling);
      }
      placeCaretAfter(mjx.nextSibling || mjx);
    }
  }
  function hardenMathJax(){
    // Make math uneditable to avoid weird cursor/selection behavior
    editor.querySelectorAll('mjx-container').forEach(m=>{
      m.setAttribute('contenteditable','false');
      m.setAttribute('draggable','false');
    });
  }

  // Keep selection updated even when user clicks around
  document.addEventListener('selectionchange', ()=>{
    if(selectionInsideEditor()){
      saveSelection();
      updateActiveFormatting();
    }
  });

  editor.addEventListener('keyup', saveSelection);
  editor.addEventListener('mouseup', saveSelection);
  editor.addEventListener('focus', saveSelection);

  function exec(cmd, val=null){
    document.execCommand(cmd, false, val);
    editor.focus();
    saveSelection();
    updateActiveFormatting();
  }

  function applyHeading(tag){
    if(tag==='p'){ document.execCommand('formatBlock', false, 'p'); }
    else document.execCommand('formatBlock', false, tag);
  }

  function selectionIntersectsMath(){
    const sel = window.getSelection();
    if(!sel || sel.rangeCount===0) return false;
    const range = sel.getRangeAt(0);
    const mathNodes = editor.querySelectorAll('mjx-container');
    for(const m of mathNodes){
      try{
        if(range.intersectsNode(m)) return true;
      }catch(_e){/* ignore */}
    }
    return false;
  }

  function applyFontSize(size){
    if(size==='default') return;
    if(selectionIntersectsMath()){
      // Apply to block to avoid wrapping math nodes
      wrapSelectionBlockStyle({ fontSize: size });
    }else{
      wrapSelectionWithSpan({ fontSize: size });
    }
  }
  function applyLineHeight(lh){
    if(lh==='default') return;
    wrapSelectionBlockStyle({ lineHeight: lh });
  }
  function wrapSelectionWithSpan(styleObj){
    restoreSelection();
    const sel = window.getSelection();
    if(!sel.rangeCount) return;
    const range = sel.getRangeAt(0);
    const span = document.createElement('span');
    Object.assign(span.style, styleObj);
    try{
      range.surroundContents(span);
    }catch(err){
      span.appendChild(range.extractContents());
      range.insertNode(span);
    }
    sel.removeAllRanges();
    const nr = document.createRange();
    nr.selectNodeContents(span);
    sel.addRange(nr);
    saveSelection();
  }
  function wrapSelectionBlockStyle(styleObj){
    restoreSelection();
    const sel = window.getSelection();
    if(!sel.rangeCount) return;
    let node = sel.anchorNode;
    if(node && node.nodeType===3) node = node.parentElement;
    const block = nearestBlock(node);
    Object.assign(block.style, styleObj);
    saveSelection();
  }

  function updateActiveFormatting(){
    const map = {
      bold: document.queryCommandState('bold'),
      italic: document.queryCommandState('italic'),
      underline: document.queryCommandState('underline')
    };
    $$('.tool-btn[data-cmd]').forEach(btn=>{
      const cmd = btn.dataset.cmd;
      if(map.hasOwnProperty(cmd)){
        btn.classList.toggle('active', !!map[cmd]);
      }
    });
  }

  // Custom Link modal
  async function insertLinkModal(){
    restoreSelection();
    const sel = window.getSelection();
    const selectedText = sel && sel.toString();
    const body = `
      <label style="display:block; font-size:13px; color:#374151; margin-bottom:6px;">Text</label>
      <input id="linkText" type="text" value="${escapeHtml(selectedText || '')}" placeholder="Link text (optional)"/>
      <div style="height:10px"></div>
      <label style="display:block; font-size:13px; color:#374151; margin-bottom:6px;">URL</label>
      <input id="linkUrl" type="url" placeholder="https://example.com"/>
    `;
    const promise = showModal({title:'Insert Link', bodyHtml:body, okText:'Insert', cancelText:'Cancel'});
    await 0;
    const okHandler = async ()=>{
      const text = $('#linkText').value.trim();
      const url = $('#linkUrl').value.trim();
      if(!url) return;
      if(selectedText){
        restoreSelection();
        document.execCommand('createLink', false, url);
        if(text && text !== selectedText){
          const a = window.getSelection().anchorNode?.parentElement?.closest('a');
          if(a){ a.textContent = text; }
        }
      }else{
        const a = document.createElement('a');
        a.href = url; a.textContent = text || url; a.target = '_blank';
        restoreSelection();
        const range = window.getSelection().getRangeAt(0);
        range.collapse(false);
        range.insertNode(a);
        placeCaretAfter(a);
      }
      saveContentDebounced();
      $('#modalBackdrop').style.display='none';
    };
    $('#modalOk').onclick = okHandler;
    $('#modalCancel').onclick = ()=> $('#modalBackdrop').style.display='none';
    $('#modalClose').onclick = ()=> $('#modalBackdrop').style.display='none';
    await promise;
  }

  // Insert Image via file input or drag-drop
  function insertImageFile(file){
    const reader = new FileReader();
    reader.onload = () => {
      const img = document.createElement('img');
      img.src = reader.result;
      img.alt = file.name || 'image';
      restoreSelection();
      const range = window.getSelection().getRangeAt(0);
      range.collapse(false);
      range.insertNode(img);
      placeCaretAfter(img);
      saveContentDebounced();
    };
    reader.readAsDataURL(file);
  }

  // Drag & Drop
  editor.addEventListener('dragover', (e)=>{
    e.preventDefault();
  });
  editor.addEventListener('drop', (e)=>{
    e.preventDefault();
    const files = e.dataTransfer.files;
    if(files && files.length){
      for(const f of files){
        if(f.type.startsWith('image/')) insertImageFile(f);
      }
    }
  });

  // Paste image support
  editor.addEventListener('paste', (e)=>{
    const items = e.clipboardData?.items || [];
    for(const it of items){
      if(it.type && it.type.startsWith('image/')){
        const file = it.getAsFile();
        if(file) insertImageFile(file);
      }
    }
  });

  // --- Caret marker helpers (robust insertion at cursor) ---
  function insertCaretMarker(){
    // Ensure there is always a stable DOM anchor even if selection is lost
    restoreSelection();
    const id = 'caret-marker-' + Date.now();
    const marker = document.createElement('span');
    marker.id = id;
    marker.style.display = 'inline-block';
    marker.style.width = '0';
    marker.style.height = '0';
    marker.style.lineHeight = '0';
    const sel = window.getSelection();
    if(sel && sel.rangeCount){
      const range = sel.getRangeAt(0).cloneRange();
      range.collapse(false);
      range.insertNode(marker);
      // keep caret after marker for visual continuity
      placeCaretAfter(marker);
    }else{
      editor.appendChild(marker);
    }
    return id;
  }
  function consumeCaretMarker(id){
    const marker = document.getElementById(id);
    return marker || null;
  }

  // Insert Formula (LaTeX) via modal
  async function insertFormula(){
    // drop a marker so we always insert at the user's caret, not at start
    const markerId = insertCaretMarker();
    const latex = await promptModal('Insert Formula', 'Enter LaTeX (inline with $...$ or display with $$...$$)', '');
    if(latex===null || latex.trim()===''){
      // remove marker and bail
      const m0 = consumeCaretMarker(markerId);
      if(m0) m0.remove();
      return;
    }
    const span = document.createElement('span');
    const content = latex.trim();
    if(content.startsWith('$$') || content.startsWith('\\[') || content.startsWith('\\(') || content.startsWith('$')){
      span.textContent = content;
    }else{
      span.textContent = '$' + content + '$';
    }
    // Find marker and insert formula right there
    const m = consumeCaretMarker(markerId);
    if(m && m.parentNode){
      m.parentNode.insertBefore(span, m);
      // always add a spacer and move caret outside
      const spacer = document.createTextNode(' ');
      m.parentNode.insertBefore(spacer, m.nextSibling);
      placeCaretAfter(spacer);
      m.remove();
    }else{
      // fallback: restore selection and insert
      editor.focus();
      restoreSelection();
      const range = window.getSelection().getRangeAt(0);
      range.collapse(false);
      range.insertNode(span);
      const spacer = document.createTextNode(' ');
      span.parentNode.insertBefore(spacer, span.nextSibling);
      placeCaretAfter(spacer);
    }
    MathJax?.typesetPromise?.([span]).then(()=>{
      hardenMathJax();
      ensureCaretOutsideMath();
    });
    saveContentDebounced();
  }

  // Clear ALL content in the editor
  async function clearEditorAll(){
    const ok = await confirmModal('Clear page', 'Clear ALL content in the editor? This cannot be undone.');
    if(!ok) return;
    editor.innerHTML = '';
    lastRange = null;
    saveContentDebounced();
    editor.focus();
  }

  // Clear formatting (selection or current block) without adding newlines
  function cleanElement(root){
    // remove inline styles & classes
    root.querySelectorAll('[style]').forEach(el=> el.removeAttribute('style'));
    root.querySelectorAll('[class]').forEach(el=> el.removeAttribute('class'));
    // headings -> paragraphs
    root.querySelectorAll('h1,h2,h3,h4,h5,h6').forEach(h=>{
      const p = document.createElement('p'); p.innerHTML = h.innerHTML; h.parentNode.replaceChild(p, h);
    });
    // unwrap pure formatting tags
    root.querySelectorAll('b,strong,i,em,u,font,span').forEach(el=>{
      if(el.tagName.toLowerCase()==='span' && el.attributes.length>0) return; // keep spans with attributes
      const parent = el.parentNode;
      while(el.firstChild) parent.insertBefore(el.firstChild, el);
      parent.removeChild(el);
    });
  }
  function clearFormatting(){
    editor.focus();
    const sel = window.getSelection();
    if(!sel.rangeCount) return;
    const range = sel.getRangeAt(0);

    if(range.collapsed){
      // operate on current block
      const block = nearestBlock(range.startContainer);
      if(block && editor.contains(block)){
        const shadow = block.cloneNode(true);
        cleanElement(shadow);
        block.replaceWith(shadow);
        placeCaretAfter(shadow);
      }
      document.execCommand('formatBlock', false, 'p');
      saveContentDebounced();
      return;
    }

    // Selection case: replace selected contents with cleaned version
    const frag = range.cloneContents();
    const temp = document.createElement('div');
    temp.appendChild(frag);
    cleanElement(temp);
    const cleanedFrag = document.createDocumentFragment();
    const nodes = Array.from(temp.childNodes);
    nodes.forEach(n=> cleanedFrag.appendChild(n));
    range.deleteContents();
    range.insertNode(cleanedFrag);
    const last = nodes[nodes.length-1];
    if(last && last.parentNode){ placeCaretAfter(last); }
    saveContentDebounced();
  }

  // Save current node content/title
  const saveContentDebounced = debounce(saveContent, 400);
  async function saveContent(){
    const node = state.nodes.find(n=>n.id===state.selectedId);
    if(!node) return;
    node.title = titleInput.value || node.title;
    node.contentHtml = editor.innerHTML;
    await idbPut(node);
    showSaved();
    if(getGhCfg().auto){ githubCommit('Auto-sync'); }
    renderTree();
  }
  function showSaved(){
    saveIndicator.textContent = 'Saved';
    const s = $('#status'); s.textContent = 'Saved'; s.classList.add('show');
    setTimeout(()=> s.classList.remove('show'), 900);
  }

  // Auto-render LaTeX after boundary chars; then force caret outside math
  const typesetDebounced = debounce(()=>{
    MathJax?.typesetPromise?.([editor]).then(()=>{
      hardenMathJax();
      ensureCaretOutsideMath();
    });
  }, 250);
  editor.addEventListener('input', (e)=>{
    saveContentDebounced();
    const ch = (e.data || '').toString();
    if(ch && /[\s),.;:!?]/.test(ch)){ typesetDebounced(); }
  });

  // ---------- Modal helpers ----------
  function showModal({title, bodyHtml, okText='OK', cancelText='Cancel'}){
    $('#modalTitle').textContent = title;
    $('#modalBody').innerHTML = bodyHtml;
    $('#modalOk').textContent = okText;
    $('#modalCancel').textContent = cancelText;
    $('#modalBackdrop').style.display='flex';
    return new Promise((resolve)=>{
      const close = (val)=>{
        $('#modalBackdrop').style.display='none';
        resolve(val);
      };
      $('#modalOk').onclick = ()=> close(true);
      $('#modalCancel').onclick = ()=> close(false);
      $('#modalClose').onclick = ()=> close(false);
    });
  }
  async function promptModal(title, placeholder, value=''){
    const promise = showModal({title, bodyHtml:`<input id="modalInput" type="text" placeholder="${escapeHtml(placeholder)}" value="${escapeHtml(value)}" />`});
    await 0; // microtask
    $('#modalInput').focus();
    return new Promise(async (resolve)=>{
      const ok = await promise;
      if(ok) resolve($('#modalInput').value);
      else resolve(null);
    });
  }
  async function confirmModal(title, message){
    const promise = showModal({title, bodyHtml:`<p>${escapeHtml(message)}</p>`, okText:'Delete', cancelText:'Cancel'});
    return promise;
  }
  function toast(text){
    const s = $('#status'); s.textContent = text; s.classList.add('show');
    setTimeout(()=> s.classList.remove('show'), 1400);
  }

  // ---------- Export / Import ----------
  async function exportAll(){
    const nodes = await idbGetAll();
    const payload = {
      version: 1,
      exportedAt: new Date().toISOString(),
      expanded: state.expanded,
      meta: {
        editPinHash: localStorage.getItem('editPinHash') || null
      },
      nodes
    };
    const blob = new Blob([JSON.stringify(payload, null, 2)], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'notes-export.json';
    document.body.appendChild(a);
    a.click();
    URL.revokeObjectURL(a.href);
    a.remove();
  }
  async function importAll(file){
    const text = await file.text();
    let data;
    try{ data = JSON.parse(text); } catch(e){ toast('Invalid JSON'); return; }
    if(!data?.nodes || !Array.isArray(data.nodes)){ toast('Invalid export file'); return; }
    await idbClear();
    for(const n of data.nodes){ await idbPut(n); }
    state.nodes = await idbGetAll();
    if(Array.isArray(data.expanded)) { state.expanded = data.expanded; persistExpanded(); }
    if(data.meta?.editPinHash){ localStorage.setItem('editPinHash', data.meta.editPinHash); }
    renderTree();
    selectNode('home');
    toast('Imported');
  }

  // ---------- Search (title + full content) ----------
  function textFromHtml(html){
    const tmp = document.createElement('div');
    tmp.innerHTML = html || '';
    return tmp.textContent || '';
  }
  function findAllOccurrences(text, query){
    const q = query.toLowerCase();
    const t = text.toLowerCase();
    const idxs = [];
    let start = 0;
    while(true){
      const i = t.indexOf(q, start);
      if(i===-1) break;
      idxs.push(i);
      start = i + q.length;
      if(idxs.length>200) break;
    }
    return idxs;
  }
  function buildSnippet(text, index, qlen){
    const start = Math.max(0, index-50);
    const end = Math.min(text.length, index+qlen+50);
    return text.slice(start, end);
  }
  async function openSearchResults(query){
    if(!query || !query.trim()){ return; }
    const q = query.trim();
    const results = [];
    for(const n of state.nodes){
      if(n.type==='page' || n.type==='home' || n.type==='section'){
        const titleMatch = n.title.toLowerCase().includes(q.toLowerCase());
        const text = textFromHtml(n.contentHtml || '');
        const idxs = findAllOccurrences(text, q);
        if(titleMatch || idxs.length){
          const snippets = idxs.slice(0,5).map(i=> buildSnippet(text, i, q.length));
          results.push({ id:n.id, title:n.title, matches:idxs.length, snippets });
        }
      }
    }
    results.sort((a,b)=> b.matches - a.matches);

    const body = results.length ? results.map(r=>{
      const snips = r.snippets.map(s=>{
        const safe = escapeHtml(s);
        const re = new RegExp(q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'ig');
        const highlighted = safe.replace(re, (m)=>`<mark>${m}</mark>`);
        return `<div class="snippet">${highlighted}</div>`;
      }).join('');
      return `<div class="result">
        <div class="where"><strong>${escapeHtml(r.title)}</strong> — ${r.matches} match(es)</div>
        ${snips}
        <div style="margin-top:6px">
          <button class="btn btn-ghost" data-open="${r.id}" data-q="${escapeHtml(q)}">Open</button>
        </div>
      </div>`;
    }).join('') : '<p>No results.</p>';

    const promise = showModal({title:`Search Results for "${escapeHtml(q)}"`, bodyHtml: body, okText:'Close', cancelText:'Close'});
    await 0; // let modal render
    const searchInput = $('#search');
    $$('#modalBody .btn[data-open]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const id = btn.getAttribute('data-open');
        const q2 = btn.getAttribute('data-q');
        $('#modalBackdrop').style.display='none';
        // Clear sidebar search and filter
        searchInput.value='';
        state.filter='';
        renderTree();
        selectNode(id).then(()=>{
          scrollToQueryInEditor(q2);
          toast('Jumped to result');
        });
      });
    });
    await promise;
  }
  function scrollToQueryInEditor(query){
    const walker = document.createTreeWalker(editor, NodeFilter.SHOW_TEXT, null);
    const q = query.toLowerCase();
    let node;
    while((node = walker.nextNode())){
      const i = node.textContent.toLowerCase().indexOf(q);
      if(i>=0){
        const range = document.createRange();
        range.setStart(node, i);
        range.setEnd(node, i+q.length);
        const rect = range.getBoundingClientRect();
        editor.scrollTop = editor.scrollTop + rect.top - editor.getBoundingClientRect().top - 60;
        const sel = window.getSelection();
        sel.removeAllRanges(); sel.addRange(range);
        setTimeout(()=> sel.removeAllRanges(), 800);
        break;
      }
    }
  }

  // ---------- GitHub Sync (optional) ----------
  function getGhCfg(){
    const raw = localStorage.getItem('ghSyncConfig');
    try{ return raw ? JSON.parse(raw) : { enabled:false, auto:false }; }catch{ return { enabled:false, auto:false }; }
  }
  function setGhCfg(cfg){
    localStorage.setItem('ghSyncConfig', JSON.stringify(cfg));
    updateEditability();
  }
  async function ghConfigModal(){
    const cfg = getGhCfg();
    const body = `
      <p style="font-size:13px; color:#374151; margin-top:0">
        Commit your notes (as JSON) directly to a GitHub repo using a fine-grained Personal Access Token (PAT). This runs entirely in your browser — your token is stored in <code>localStorage</code> on this device only.
      </p>
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px">
        <div>
          <label style="font-size:12px">Owner</label>
          <input id="ghOwner" type="text" value="${escapeHtml(cfg.owner||'')}" placeholder="your-username"/>
        </div>
        <div>
          <label style="font-size:12px">Repo</label>
          <input id="ghRepo" type="text" value="${escapeHtml(cfg.repo||'')}" placeholder="notes-repo"/>
        </div>
        <div>
          <label style="font-size:12px">Branch</label>
          <input id="ghBranch" type="text" value="${escapeHtml(cfg.branch||'main')}" placeholder="main"/>
        </div>
        <div>
          <label style="font-size:12px">Path</label>
          <input id="ghPath" type="text" value="${escapeHtml(cfg.path||'notes-export.json')}" placeholder="path/in/repo/notes.json"/>
        </div>
      </div>
      <div style="margin-top:10px">
        <label style="font-size:12px">PAT (fine-grained, Contents: Read/Write for this repo only)</label>
        <input id="ghToken" type="text" value="${escapeHtml(cfg.token||'')}" placeholder="ghp_..."/>
      </div>
      <div style="margin-top:10px">
        <label><input id="ghEnabled" type="checkbox" ${cfg.enabled?'checked':''}/> Enable GitHub Sync</label>
        <label style="margin-left:14px"><input id="ghAuto" type="checkbox" ${cfg.auto?'checked':''}/> Auto-sync on save</label>
      </div>
      <div style="margin-top:10px; display:flex; gap:8px">
        <button class="btn btn-ghost" id="ghTest">Test & Save</button>
        <button class="btn btn-ghost" id="ghPush">Sync Now</button>
      </div>
      <hr style="margin:16px 0">
      <p style="font-size:13px; color:#374151; margin-top:0"><strong>Owner Edit PIN</strong> (store hash in JSON so others cannot set their own)</p>
      <div style="display:grid; grid-template-columns:1fr 1fr; gap:10px">
        <div>
          <label style="font-size:12px">Set/Change PIN</label>
          <input id="pinSet" type="password" placeholder="new PIN"/>
        </div>
        <div>
          <label style="font-size:12px">Confirm</label>
          <input id="pinSet2" type="password" placeholder="confirm PIN"/>
        </div>
      </div>
      <div style="margin-top:10px">
        <button class="btn btn-ghost" id="pinSave">Save PIN</button>
      </div>
    `;
    const promise = showModal({title:'GitHub Sync & Owner Settings', bodyHtml: body, okText:'Close', cancelText:'Close'});
    (async ()=>{
      await 0;
      const collect = ()=> ({
        owner: $('#ghOwner').value.trim(),
        repo: $('#ghRepo').value.trim(),
        branch: $('#ghBranch').value.trim() || 'main',
        path: $('#ghPath').value.trim() || 'notes-export.json',
        token: $('#ghToken').value.trim(),
        enabled: $('#ghEnabled').checked,
        auto: $('#ghAuto').checked
      });
      $('#ghTest').onclick = async ()=>{
        const ncfg = collect();
        setGhCfg(ncfg);
        const ok = await githubCommit('Test commit (dry run)', true);
        toast(ok ? 'Config looks good' : 'Config failed');
      };
      $('#ghPush').onclick = async ()=>{
        const ncfg = collect();
        setGhCfg(ncfg);
        const ok = await githubCommit('Manual sync');
        toast(ok ? 'Synced to GitHub' : 'Sync failed');
      };
      $('#pinSave').onclick = async ()=>{
        const p1 = $('#pinSet').value;
        const p2 = $('#pinSet2').value;
        if(!p1 || p1!==p2){ toast('PIN mismatch'); return; }
        const hash = await sha256(p1);
        localStorage.setItem('editPinHash', hash);
        // commit immediately so viewers inherit the same lock
        const ok = await githubCommit('Update owner PIN (hash in JSON)');
        toast(ok ? 'PIN saved & synced' : 'PIN saved locally');
      };
    })();
    return promise;
  }

  function getEditEnabled(){ return localStorage.getItem('editingEnabled')==='true'; }
  function setEditEnabled(v){ localStorage.setItem('editingEnabled', v ? 'true' : 'false'); updateEditability(); }

  async function toggleEdit(){
    const enabled = getEditEnabled();
    if(enabled){
      setEditEnabled(false);
      toast('Editing locked');
      return;
    }
    // Require an existing PIN; do NOT allow anyone to create one from locked state
    const pinHash = localStorage.getItem('editPinHash');
    if(!pinHash){
      toast('Owner PIN not set. Ask the owner to set it via GitHub Sync.');
      return;
    }
    const p = await promptSecure('Unlock Editing', 'Enter PIN to unlock');
    if(!p) return;
    const hash = await sha256(p);
    if(hash===pinHash){
      setEditEnabled(true);
      toast('Editing unlocked');
    }else{
      toast('Incorrect PIN');
    }
  }

  function updateEditability(){
    const editable = getEditEnabled();
    $('#toolbar').classList.toggle('disabled', !editable);
    $('#editor').setAttribute('contenteditable', editable ? 'true' : 'false');
    $('#addSectionBtn').disabled = !editable;
    $('#addPageBtn').disabled = !editable;
    $('#titleInput').disabled = !editable;
    // Button label reflects actual state
    $('#editToggleBtn').textContent = editable ? 'Lock Editing' : 'Unlock Editing';
    // GitHub Sync hidden when locked
    const ghBtn = $('#githubBtn');
    if(ghBtn) ghBtn.style.display = editable ? 'inline-block' : 'none';
  }

  async function promptSecure(title, placeholder){
    const promise = showModal({title, bodyHtml:`<input id="secureInput" type="password" placeholder="${escapeHtml(placeholder)}" />`, okText:'OK', cancelText:'Cancel'});
    await 0; $('#secureInput').focus();
    const ok = await promise;
    if(ok) return $('#secureInput').value;
    return null;
  }

  async function githubCommit(message, dryRun=false){
    const cfg = getGhCfg();
    if(!cfg.enabled){ return false; }
    if(!cfg.owner || !cfg.repo || !cfg.branch || !cfg.path || !cfg.token){ toast('GitHub config incomplete'); return false; }
    const payload = {
      version: 1,
      exportedAt: new Date().toISOString(),
      expanded: state.expanded,
      meta: {
        editPinHash: localStorage.getItem('editPinHash') || null
      },
      nodes: await idbGetAll()
    };
    const content = utf8ToB64(JSON.stringify(payload, null, 2));
    const base = `https://api.github.com/repos/${encodeURIComponent(cfg.owner)}/${encodeURIComponent(cfg.repo)}/contents/${cfg.path}`;
    const headers = {
      'Authorization': `Bearer ${cfg.token}`,
      'Accept': 'application/vnd.github+json'
    };
    // get SHA if file exists
    let sha=null;
    try{
      const getRes = await fetch(`${base}?ref=${encodeURIComponent(cfg.branch)}`, { headers });
      if(getRes.ok){
        const info = await getRes.json();
        sha = info.sha;
      }
    }catch(e){ /* ignore */ }
    if(dryRun) return true;
    try{
      const putRes = await fetch(base, {
        method:'PUT',
        headers,
        body: JSON.stringify({ message, content, branch: cfg.branch, sha: sha || undefined })
      });
      if(!putRes.ok){
        console.error('GitHub PUT failed', await putRes.text());
        return false;
      }
      return true;
    }catch(e){
      console.error('GitHub error', e);
      return false;
    }
  }

  // ---------- Always load from repo copy when available ----------
  async function loadFromRemoteNotesIfAvailable({silent=false}={}){
    try{
      const url = `${location.origin}/notes-export.json?cache=${Date.now()}`;
      const res = await fetch(url, { cache:'no-store' });
      if(!res.ok) return;
      const data = await res.json();
      if(!Array.isArray(data?.nodes)) return;
      await idbClear();
      for(const n of data.nodes){ await idbPut(n); }
      state.nodes = await idbGetAll();
      if(Array.isArray(data.expanded)){ state.expanded = data.expanded; persistExpanded(); }
      if(data.meta?.editPinHash){ localStorage.setItem('editPinHash', data.meta.editPinHash); }
      renderTree();
      selectNode(state.selectedId || 'home');
      if(!silent) toast('Loaded latest notes from repo');
    }catch(e){
      if(!silent) console.warn('Remote notes load failed', e);
    }
  }

  // ---------- Event wiring ----------
  async function init(){
    db = await idbOpen();
    state.nodes = await idbGetAll();
    await ensureHome();
    renderTree();
    selectNode(state.selectedId);

    // Try to hydrate from the repo's JSON so every viewer sees the same content
    loadFromRemoteNotesIfAvailable({silent:true});

    // Re-hydrate when tab becomes visible (pull latest)
    document.addEventListener('visibilitychange', ()=>{
      if(document.visibilityState === 'visible'){
        loadFromRemoteNotesIfAvailable({silent:true});
      }
    });

    // Toolbar
    $('#toolbar').addEventListener('click', (e)=>{
      const btn = e.target.closest('.tool-btn');
      if(!btn) return;
      const cmd = btn.dataset.cmd;
      if(!cmd) return;
      exec(cmd);
      saveContentDebounced();
    });
    $('#headingSelect').onchange = (e)=>{ applyHeading(e.target.value); saveContentDebounced(); };
    $('#fontSizeSelect').onchange = (e)=>{ applyFontSize(e.target.value); saveContentDebounced(); e.target.value='default'; };
    $('#lineHeightSelect').onchange = (e)=>{ applyLineHeight(e.target.value); saveContentDebounced(); e.target.value='default'; };
    $('#colorPicker').oninput = (e)=>{ exec('foreColor', e.target.value); saveContentDebounced(); };
    $('#linkBtn').onclick = ()=> insertLinkModal();
    $('#imageBtn').onclick = ()=> $('#imageInput').click();
    $('#imageInput').onchange = (e)=>{
      const f = e.target.files?.[0]; if(f) insertImageFile(f);
      e.target.value='';
    };
    $('#formulaBtn').onclick = ()=> insertFormula();
    // Preserve caret when clicking toolbar buttons (prevents focus loss)
    $('#toolbar').addEventListener('mousedown', (e)=>{
      if (e.target.closest('.tool-btn') || e.target.id === 'colorPicker') {
        e.preventDefault();
      }
    }, true);
    $('#clearFormatBtn').onclick = ()=> clearEditorAll();
    $('#clearFormatBtn').title = 'Clear all content';

    // Title / content save
    $('#titleInput').addEventListener('input', saveContentDebounced);
    editor.addEventListener('input', ()=>{ saveContentDebounced(); });

    // Add buttons
    $('#addSectionBtn').onclick = addSection;
    $('#addPageBtn').onclick = async ()=>{
      const sel = state.nodes.find(n=>n.id===state.selectedId);
      let parentId;
      if(sel?.type==='section') parentId = sel.id;
      else {
        const sections = state.nodes.filter(n=>n.type==='section');
        if(sections.length===0){
          await addSection();
          parentId = state.nodes.filter(n=>n.type==='section').slice(-1)[0]?.id;
        }else{
          const options = sections.map(s=>`<option value="${s.id}">${escapeHtml(s.title)}</option>`).join('');
          const promise = showModal({title:'Add Page', bodyHtml:`
            <label for="sectionSelect" style="display:block; font-size:13px; color:#374151; margin-bottom:6px;">Choose a section</label>
            <select id="sectionSelect" style="width:100%; padding:10px; border:1px solid var(--border); border-radius:8px">
              ${options}
            </select>
          `, okText:'Next', cancelText:'Cancel'});
          await 0;
          parentId = $('#sectionSelect').value;
          const ok = await promise;
          if(!ok) return;
        }
      }
      await addPage(parentId);
    };

    // Search filter + open results on Enter
    $('#search').addEventListener('input', (e)=>{
      state.filter = e.target.value;
      renderTree();
    });
    $('#search').addEventListener('keydown', (e)=>{
      if(e.key==='Enter'){
        e.preventDefault();
        openSearchResults($('#search').value);
      }
    });

    // Export/Import
    $('#exportBtn').onclick = exportAll;
    $('#importBtn').onclick = ()=> $('#importFile').click();
    $('#importFile').onchange = (e)=>{
      const file = e.target.files?.[0];
      if(file) importAll(file);
      e.target.value='';
    };

    // GitHub Sync
    $('#githubBtn').onclick = ()=> ghConfigModal();

    // Edit lock
    $('#editToggleBtn').onclick = ()=> toggleEdit();

    // Keyboard: Ctrl/Cmd+S to save; Ctrl/Cmd+K for link
    document.addEventListener('keydown', (e)=>{
      if((e.metaKey || e.ctrlKey) && e.key.toLowerCase()==='s'){ e.preventDefault(); saveContent(); }
      if((e.metaKey || e.ctrlKey) && e.key.toLowerCase()==='k'){ e.preventDefault(); insertLinkModal(); }
    });

    updateEditability();
  }

  // ---------- Kickoff ----------
  init();
})();</script>
</body>
</html>
